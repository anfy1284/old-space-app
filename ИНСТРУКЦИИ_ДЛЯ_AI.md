# ИНСТРУКЦИИ ДЛЯ AI АССИСТЕНТА (v3.1)

Этот документ — **правила работы**. Техническую структуру классов, методов и протоколов см. в [АРХИТЕКТУРА_ПРОЕКТА.md](АРХИТЕКТУРА_ПРОЕКТА.md).

---

## 1. РЕЖИМ РАБОТЫ И КОММУНИКАЦИЯ

### Начало и завершение задачи
- **СТАРТ:** При получении команды "сначала прочти инструкции" — автоматически и полностью перечитывай этот файл и [АРХИТЕКТУРА_ПРОЕКТА.md](АРХИТЕКТУРА_ПРОЕКТА.md). Не спрашивай разрешения на чтение.
- **В ПРОЦЕССЕ:** Перед любыми правками кода отправь 1-2 коротких предложения: что собираешься сделать и в каком файле.
- **СТОП:** Если решение может нарушить архитектуру или ты сомневаешься — остановись и уточни у пользователя.
- **ФИНАЛ:** По команде "дополни инструкции" — проанализируй чат, найди ошибки, обнови этот файл и/или `АРХИТЕКТУРА_ПРОЕКТА.md`. Архитектурные детали (классы, методы, свойства, протоколы) — в архитектуру; правила, анти-паттерны, процессы — в инструкции.
- **РЕФАКТОРИНГ:** При каждом обновлении — убирай дублирование между этим файлом и архитектурой.
- **ЯЗЫК:** Общайся с пользователем на русском языке.

### Технические правила (CRITICAL)
- **Правка файлов:** КАТЕГОРИЧЕСКИ ЗАПРЕЩЕНО использовать команды терминала (`run_in_terminal`, `sed`, `echo >` и т.д.) для создания или редактирования файлов. Используй только специализированные инструменты (`replace_string_in_file`, `create_file`). Это необходимо для прозрачности изменений и возможности их отката.
- **node_modules:** Допускается точечная правка системных библиотек (например, `my-old-space`), если проблема в базовом классе.

### Правила взаимодействия
- **Слушай фидбек:** Если пользователь говорит "это не то" или "это костыль" — не защищай решение. Признай ошибку и смени стратегию.
- **Минимализм:** Делай точечные изменения. Не рефактори лишнее, если не просили. Используй существующие параметры (например, `openParams`, `appForm`, `instance`).

---

## 2. ПРИНЦИПЫ КОДИРОВАНИЯ

### Системность
- **Базовые классы прежде всего:** Приоритет правки в `UI_classes.js`. Решение в базовом классе исправляет баг во всех приложениях.
- **Связь DOM ↔ Объект:** Всегда пробрасывай `element._uiObject = this;`.
- **Idempotent Rendering:** `Draw` и загрузка данных должны учитывать текущее состояние (сортировка, ширины колонок).
- **Минимальное логирование:** Удали `console.log` после исправления. Оставляй только ошибки.

### События
- **Флаги вместо таймаутов:** Для разделения drag/click используй внутренние флаги (`this._resizeOccurred`), а не `setTimeout`.
- **Координация кликов:** `ev.__checkboxHandled = true` для предотвращения двойного срабатывания.
- **`form-destroyed`:** Для реакции на закрытие формы из другого контекста слушай это глобальное событие. Не оборачивай `inst.destroy`.

### Замыкания и контекст
- **`this` в callback'ах:** Перед передачей обработчика в `addEventListener` сохраняй ссылку: `const formSelf = this;`.
- **RPC параметры:** Первый аргумент серверного метода — один объект `params`, не отдельные аргументы.

---

## 3. UI И СТИЛЬ (WIN95)

- **CSS-First:** Проверяй `style.css` перед изменением JS.
- **Никаких inline-стилей** для статичных свойств — используй классы.
- **Lifecycle:** Удаляй `ResizeObserver` и `EventListener` в `destroy()`.
- **`table-layout: fixed`** для таблиц с управляемой шириной колонок.

---

## 4. АНТИ-ПАТТЕРНЫ

- ❌ **`setTimeout`** для ожидания отрисовки. Используй флаги.
- ❌ **`innerHTML`/`textContent`** на узлах с интерактивными детьми. Создавай `span`.
- ❌ **`window.something`** для связи между локальными объектами.
- ❌ **Индексы** (`layout[0]`, `firstElementChild`). Используй именованные ссылки.
- ❌ **Обёртка `inst.destroy`** для реакции на закрытие. Используй событие `form-destroyed`.
- ❌ **Терминал** для редактирования файлов.

---

## 5. ЧЕКЛИСТ САМОПРОВЕРКИ

1. Я поискал решение в базовом классе (`UI_classes.js`) прежде чем писать код в приложении?
2. Сохранятся ли ширины колонок и сортировка после обновления данных?
3. Нет лишнего `click` после `drag`? Использован флаг, а не `setTimeout`?
4. Новые стили вынесены в CSS?
5. Есть очистка в `destroy()`?
6. Файл правится через `replace_string_in_file`, а не через терминал?
7. RPC: `params` — один объект, первый аргумент?
8. Dataset: контекст сохранён через `dataApp.storeDataset()`?
9. Dirty tracking: при новом контроле подключён `setModified(true)` на событие изменения?
10. Закрытие формы: используется `form-destroyed`, а не обёртка `destroy`?
